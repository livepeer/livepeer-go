// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"errors"
	"livepeer/internal/utils"
)

// IpfsExportParams2 - Custom credentials for the Piñata service. Must have either
// a JWT or an API key and an API secret.
type IpfsExportParams2 struct {
	// Will be added to the pinata_api_key header.
	APIKey string `json:"apiKey"`
	// Will be added to the pinata_secret_api_key header.
	APISecret string `json:"apiSecret"`
}

func (o *IpfsExportParams2) GetAPIKey() string {
	if o == nil {
		return ""
	}
	return o.APIKey
}

func (o *IpfsExportParams2) GetAPISecret() string {
	if o == nil {
		return ""
	}
	return o.APISecret
}

// IpfsExportParamsSchemas1 - Custom credentials for the Piñata service. Must have either
// a JWT or an API key and an API secret.
type IpfsExportParamsSchemas1 struct {
	// Will be added to the Authorization header as a
	// Bearer token.
	//
	Jwt string `json:"jwt"`
}

func (o *IpfsExportParamsSchemas1) GetJwt() string {
	if o == nil {
		return ""
	}
	return o.Jwt
}

type PinataType string

const (
	PinataTypeIpfsExportParamsSchemas1 PinataType = "ipfs-export-params_Schemas_1"
	PinataTypeIpfsExportParams2        PinataType = "ipfs-export-params_2"
)

type Pinata struct {
	IpfsExportParamsSchemas1 *IpfsExportParamsSchemas1
	IpfsExportParams2        *IpfsExportParams2

	Type PinataType
}

func CreatePinataIpfsExportParamsSchemas1(ipfsExportParamsSchemas1 IpfsExportParamsSchemas1) Pinata {
	typ := PinataTypeIpfsExportParamsSchemas1

	return Pinata{
		IpfsExportParamsSchemas1: &ipfsExportParamsSchemas1,
		Type:                     typ,
	}
}

func CreatePinataIpfsExportParams2(ipfsExportParams2 IpfsExportParams2) Pinata {
	typ := PinataTypeIpfsExportParams2

	return Pinata{
		IpfsExportParams2: &ipfsExportParams2,
		Type:              typ,
	}
}

func (u *Pinata) UnmarshalJSON(data []byte) error {

	ipfsExportParamsSchemas1 := IpfsExportParamsSchemas1{}
	if err := utils.UnmarshalJSON(data, &ipfsExportParamsSchemas1, "", true, true); err == nil {
		u.IpfsExportParamsSchemas1 = &ipfsExportParamsSchemas1
		u.Type = PinataTypeIpfsExportParamsSchemas1
		return nil
	}

	ipfsExportParams2 := IpfsExportParams2{}
	if err := utils.UnmarshalJSON(data, &ipfsExportParams2, "", true, true); err == nil {
		u.IpfsExportParams2 = &ipfsExportParams2
		u.Type = PinataTypeIpfsExportParams2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Pinata) MarshalJSON() ([]byte, error) {
	if u.IpfsExportParamsSchemas1 != nil {
		return utils.MarshalJSON(u.IpfsExportParamsSchemas1, "", true)
	}

	if u.IpfsExportParams2 != nil {
		return utils.MarshalJSON(u.IpfsExportParams2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type IpfsExportParams1 struct {
	// Name of the NFT metadata template to export. 'player'
	// will embed the Livepeer Player on the NFT while 'file'
	// will reference only the immutable MP4 files.
	//
	NftMetadataTemplate *NftMetadataTemplate `default:"file" json:"nftMetadataTemplate"`
	// Additional data to add to the NFT metadata exported to
	// IPFS. Will be deep merged with the default metadata
	// exported.
	//
	NftMetadata *NftMetadata `json:"nftMetadata,omitempty"`
	// Custom credentials for the Piñata service. Must have either
	// a JWT or an API key and an API secret.
	//
	Pinata *Pinata `json:"pinata,omitempty"`
}

func (i IpfsExportParams1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IpfsExportParams1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *IpfsExportParams1) GetNftMetadataTemplate() *NftMetadataTemplate {
	if o == nil {
		return nil
	}
	return o.NftMetadataTemplate
}

func (o *IpfsExportParams1) GetNftMetadata() *NftMetadata {
	if o == nil {
		return nil
	}
	return o.NftMetadata
}

func (o *IpfsExportParams1) GetPinata() *Pinata {
	if o == nil {
		return nil
	}
	return o.Pinata
}
