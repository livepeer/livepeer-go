// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/livepeer/livepeer-go/internal/utils"
)

type ThreeType string

const (
	ThreeTypeStr    ThreeType = "str"
	ThreeTypeNumber ThreeType = "number"
)

type Three struct {
	Str    *string
	Number *float64

	Type ThreeType
}

func CreateThreeStr(str string) Three {
	typ := ThreeTypeStr

	return Three{
		Str:  &str,
		Type: typ,
	}
}

func CreateThreeNumber(number float64) Three {
	typ := ThreeTypeNumber

	return Three{
		Number: &number,
		Type:   typ,
	}
}

func (u *Three) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ThreeTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = ThreeTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Three", string(data))
}

func (u Three) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type Three: all fields are null")
}

type StreamUserTagsType string

const (
	StreamUserTagsTypeStr      StreamUserTagsType = "str"
	StreamUserTagsTypeNumber   StreamUserTagsType = "number"
	StreamUserTagsTypeArrayOf3 StreamUserTagsType = "arrayOf3"
)

type StreamUserTags struct {
	Str      *string
	Number   *float64
	ArrayOf3 []Three

	Type StreamUserTagsType
}

func CreateStreamUserTagsStr(str string) StreamUserTags {
	typ := StreamUserTagsTypeStr

	return StreamUserTags{
		Str:  &str,
		Type: typ,
	}
}

func CreateStreamUserTagsNumber(number float64) StreamUserTags {
	typ := StreamUserTagsTypeNumber

	return StreamUserTags{
		Number: &number,
		Type:   typ,
	}
}

func CreateStreamUserTagsArrayOf3(arrayOf3 []Three) StreamUserTags {
	typ := StreamUserTagsTypeArrayOf3

	return StreamUserTags{
		ArrayOf3: arrayOf3,
		Type:     typ,
	}
}

func (u *StreamUserTags) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = StreamUserTagsTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = StreamUserTagsTypeNumber
		return nil
	}

	var arrayOf3 []Three = []Three{}
	if err := utils.UnmarshalJSON(data, &arrayOf3, "", true, true); err == nil {
		u.ArrayOf3 = arrayOf3
		u.Type = StreamUserTagsTypeArrayOf3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for StreamUserTags", string(data))
}

func (u StreamUserTags) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.ArrayOf3 != nil {
		return utils.MarshalJSON(u.ArrayOf3, "", true)
	}

	return nil, errors.New("could not marshal union type StreamUserTags: all fields are null")
}

// IsMobile1 - 0: not mobile, 1: mobile screen share, 2: mobile camera.
type IsMobile1 int64

const (
	IsMobile1Zero IsMobile1 = 0
	IsMobile1One  IsMobile1 = 1
	IsMobile1Two  IsMobile1 = 2
)

func (e IsMobile1) ToPointer() *IsMobile1 {
	return &e
}
func (e *IsMobile1) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		fallthrough
	case 2:
		*e = IsMobile1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IsMobile1: %v", v)
	}
}

type StreamIsMobileType string

const (
	StreamIsMobileTypeIsMobile1 StreamIsMobileType = "isMobile_1"
	StreamIsMobileTypeBoolean   StreamIsMobileType = "boolean"
)

// StreamIsMobile - Indicates whether the stream will be pulled from a mobile source.
type StreamIsMobile struct {
	IsMobile1 *IsMobile1
	Boolean   *bool

	Type StreamIsMobileType
}

func CreateStreamIsMobileIsMobile1(isMobile1 IsMobile1) StreamIsMobile {
	typ := StreamIsMobileTypeIsMobile1

	return StreamIsMobile{
		IsMobile1: &isMobile1,
		Type:      typ,
	}
}

func CreateStreamIsMobileBoolean(boolean bool) StreamIsMobile {
	typ := StreamIsMobileTypeBoolean

	return StreamIsMobile{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *StreamIsMobile) UnmarshalJSON(data []byte) error {

	var isMobile1 IsMobile1 = IsMobile1(0)
	if err := utils.UnmarshalJSON(data, &isMobile1, "", true, true); err == nil {
		u.IsMobile1 = &isMobile1
		u.Type = StreamIsMobileTypeIsMobile1
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = StreamIsMobileTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for StreamIsMobile", string(data))
}

func (u StreamIsMobile) MarshalJSON() ([]byte, error) {
	if u.IsMobile1 != nil {
		return utils.MarshalJSON(u.IsMobile1, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type StreamIsMobile: all fields are null")
}

// StreamLocation - Approximate location of the pull source. The location is used to
// determine the closest Livepeer region to pull the stream from.
type StreamLocation struct {
	// Latitude of the pull source in degrees. North is positive,
	// south is negative.
	Lat float64 `json:"lat"`
	// Longitude of the pull source in degrees. East is positive,
	// west is negative.
	Lon float64 `json:"lon"`
}

func (o *StreamLocation) GetLat() float64 {
	if o == nil {
		return 0.0
	}
	return o.Lat
}

func (o *StreamLocation) GetLon() float64 {
	if o == nil {
		return 0.0
	}
	return o.Lon
}

// StreamPull - Configuration for a stream that should be actively pulled from an
// external source, rather than pushed to Livepeer. If specified, the
// stream will not have a streamKey.
type StreamPull struct {
	// URL from which to pull from.
	Source string `json:"source"`
	// Headers to be sent with the request to the pull source.
	Headers map[string]string `json:"headers,omitempty"`
	// Indicates whether the stream will be pulled from a mobile source.
	IsMobile *StreamIsMobile `json:"isMobile,omitempty"`
	// Approximate location of the pull source. The location is used to
	// determine the closest Livepeer region to pull the stream from.
	Location *StreamLocation `json:"location,omitempty"`
}

func (o *StreamPull) GetSource() string {
	if o == nil {
		return ""
	}
	return o.Source
}

func (o *StreamPull) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *StreamPull) GetIsMobile() *StreamIsMobile {
	if o == nil {
		return nil
	}
	return o.IsMobile
}

func (o *StreamPull) GetLocation() *StreamLocation {
	if o == nil {
		return nil
	}
	return o.Location
}

type StreamMultistream struct {
	// References to targets where this stream will be simultaneously
	// streamed to
	//
	Targets []TargetOutput `json:"targets,omitempty"`
}

func (o *StreamMultistream) GetTargets() []TargetOutput {
	if o == nil {
		return nil
	}
	return o.Targets
}

type Renditions struct {
}

type Stream struct {
	ID   *string `json:"id,omitempty"`
	Name string  `json:"name"`
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	Kind      *string    `json:"kind,omitempty"`
	CreatorID *CreatorID `json:"creatorId,omitempty"`
	// User input tags associated with the stream
	UserTags           map[string]StreamUserTags `json:"userTags,omitempty"`
	LastSeen           *float64                  `json:"lastSeen,omitempty"`
	SourceSegments     *float64                  `json:"sourceSegments,omitempty"`
	TranscodedSegments *float64                  `json:"transcodedSegments,omitempty"`
	// Duration of all the source segments, sec
	SourceSegmentsDuration *float64 `json:"sourceSegmentsDuration,omitempty"`
	// Duration of all the transcoded segments, sec
	TranscodedSegmentsDuration *float64 `json:"transcodedSegmentsDuration,omitempty"`
	SourceBytes                *float64 `json:"sourceBytes,omitempty"`
	TranscodedBytes            *float64 `json:"transcodedBytes,omitempty"`
	// Rate at which sourceBytes increases (bytes/second)
	IngestRate *float64 `json:"ingestRate,omitempty"`
	// Rate at which transcodedBytes increases (bytes/second)
	OutgoingRate *float64 `json:"outgoingRate,omitempty"`
	// If currently active
	IsActive *bool `json:"isActive,omitempty"`
	// Indicates whether the stream is healthy or not.
	IsHealthy *bool `json:"isHealthy,omitempty"`
	// A string array of human-readable errors describing issues affecting the stream, if any.
	Issues []string `json:"issues,omitempty"`
	// Name of the token used to create this object
	CreatedByTokenName *string `json:"createdByTokenName,omitempty"`
	// Timestamp (in milliseconds) at which stream object was created
	CreatedAt *float64 `json:"createdAt,omitempty"`
	// Points to parent stream object
	ParentID *string `json:"parentId,omitempty"`
	// Used to form RTMP ingest URL
	StreamKey *string `json:"streamKey,omitempty"`
	// Configuration for a stream that should be actively pulled from an
	// external source, rather than pushed to Livepeer. If specified, the
	// stream will not have a streamKey.
	Pull *StreamPull `json:"pull,omitempty"`
	// The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
	PlaybackID *string `json:"playbackId,omitempty"`
	// Whether the playback policy for a asset or stream is public or signed
	PlaybackPolicy *PlaybackPolicy `json:"playbackPolicy,omitempty"`
	Profiles       []FfmpegProfile `json:"profiles,omitempty"`
	// Should this stream be recorded? Uses default settings. For more
	// customization, create and configure an object store.
	//
	Record      *bool              `json:"record,omitempty"`
	Multistream *StreamMultistream `json:"multistream,omitempty"`
	// If currently suspended
	Suspended *bool `json:"suspended,omitempty"`
	// Timestamp (in milliseconds) when the stream was last terminated
	LastTerminatedAt *float64 `json:"lastTerminatedAt,omitempty"`
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	UserID     *string     `json:"userId,omitempty"`
	Renditions *Renditions `json:"renditions,omitempty"`
}

func (o *Stream) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Stream) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Stream) GetKind() *string {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *Stream) GetCreatorID() *CreatorID {
	if o == nil {
		return nil
	}
	return o.CreatorID
}

func (o *Stream) GetUserTags() map[string]StreamUserTags {
	if o == nil {
		return nil
	}
	return o.UserTags
}

func (o *Stream) GetLastSeen() *float64 {
	if o == nil {
		return nil
	}
	return o.LastSeen
}

func (o *Stream) GetSourceSegments() *float64 {
	if o == nil {
		return nil
	}
	return o.SourceSegments
}

func (o *Stream) GetTranscodedSegments() *float64 {
	if o == nil {
		return nil
	}
	return o.TranscodedSegments
}

func (o *Stream) GetSourceSegmentsDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.SourceSegmentsDuration
}

func (o *Stream) GetTranscodedSegmentsDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.TranscodedSegmentsDuration
}

func (o *Stream) GetSourceBytes() *float64 {
	if o == nil {
		return nil
	}
	return o.SourceBytes
}

func (o *Stream) GetTranscodedBytes() *float64 {
	if o == nil {
		return nil
	}
	return o.TranscodedBytes
}

func (o *Stream) GetIngestRate() *float64 {
	if o == nil {
		return nil
	}
	return o.IngestRate
}

func (o *Stream) GetOutgoingRate() *float64 {
	if o == nil {
		return nil
	}
	return o.OutgoingRate
}

func (o *Stream) GetIsActive() *bool {
	if o == nil {
		return nil
	}
	return o.IsActive
}

func (o *Stream) GetIsHealthy() *bool {
	if o == nil {
		return nil
	}
	return o.IsHealthy
}

func (o *Stream) GetIssues() []string {
	if o == nil {
		return nil
	}
	return o.Issues
}

func (o *Stream) GetCreatedByTokenName() *string {
	if o == nil {
		return nil
	}
	return o.CreatedByTokenName
}

func (o *Stream) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Stream) GetParentID() *string {
	if o == nil {
		return nil
	}
	return o.ParentID
}

func (o *Stream) GetStreamKey() *string {
	if o == nil {
		return nil
	}
	return o.StreamKey
}

func (o *Stream) GetPull() *StreamPull {
	if o == nil {
		return nil
	}
	return o.Pull
}

func (o *Stream) GetPlaybackID() *string {
	if o == nil {
		return nil
	}
	return o.PlaybackID
}

func (o *Stream) GetPlaybackPolicy() *PlaybackPolicy {
	if o == nil {
		return nil
	}
	return o.PlaybackPolicy
}

func (o *Stream) GetProfiles() []FfmpegProfile {
	if o == nil {
		return nil
	}
	return o.Profiles
}

func (o *Stream) GetRecord() *bool {
	if o == nil {
		return nil
	}
	return o.Record
}

func (o *Stream) GetMultistream() *StreamMultistream {
	if o == nil {
		return nil
	}
	return o.Multistream
}

func (o *Stream) GetSuspended() *bool {
	if o == nil {
		return nil
	}
	return o.Suspended
}

func (o *Stream) GetLastTerminatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.LastTerminatedAt
}

func (o *Stream) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *Stream) GetRenditions() *Renditions {
	if o == nil {
		return nil
	}
	return o.Renditions
}
