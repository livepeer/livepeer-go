// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"livepeer/internal/utils"
)

type StreamTargets struct {
	// Name of the transcoding profile that should be sent. Use
	// "source" for pushing the source stream data
	//
	Profile string `json:"profile"`
	// If true, the stream audio will be muted, and only silent
	// video will be pushed to the target.
	//
	VideoOnly *bool `default:"false" json:"videoOnly"`
	// ID of the multistream target object where to push this stream
	ID *string `json:"id,omitempty"`
}

func (s StreamTargets) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *StreamTargets) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *StreamTargets) GetProfile() string {
	if o == nil {
		return ""
	}
	return o.Profile
}

func (o *StreamTargets) GetVideoOnly() *bool {
	if o == nil {
		return nil
	}
	return o.VideoOnly
}

func (o *StreamTargets) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

type StreamMultistream struct {
	// References to targets where this stream will be simultaneously
	// streamed to
	//
	Targets []StreamTargets `json:"targets,omitempty"`
}

func (o *StreamMultistream) GetTargets() []StreamTargets {
	if o == nil {
		return nil
	}
	return o.Targets
}

type Stream struct {
	ID                 *string    `json:"id,omitempty"`
	Name               string     `json:"name"`
	CreatorID          *CreatorID `json:"creatorId,omitempty"`
	LastSeen           *float64   `json:"lastSeen,omitempty"`
	SourceSegments     *float64   `json:"sourceSegments,omitempty"`
	TranscodedSegments *float64   `json:"transcodedSegments,omitempty"`
	// Duration of all the source segments, sec
	SourceSegmentsDuration *float64 `json:"sourceSegmentsDuration,omitempty"`
	// Duration of all the transcoded segments, sec
	TranscodedSegmentsDuration *float64 `json:"transcodedSegmentsDuration,omitempty"`
	SourceBytes                *float64 `json:"sourceBytes,omitempty"`
	TranscodedBytes            *float64 `json:"transcodedBytes,omitempty"`
	// Rate at which sourceBytes increases (bytes/second)
	IngestRate *float64 `json:"ingestRate,omitempty"`
	// Rate at which transcodedBytes increases (bytes/second)
	OutgoingRate *float64 `json:"outgoingRate,omitempty"`
	// If currently active
	IsActive *bool `json:"isActive,omitempty"`
	// Indicates whether the stream is healthy or not.
	IsHealthy *bool `json:"isHealthy,omitempty"`
	// A string array of human-readable errors describing issues affecting
	// the stream, if any.
	//
	Issues []string `json:"issues,omitempty"`
	// Name of the token used to create this object
	CreatedByTokenName *string `json:"createdByTokenName,omitempty"`
	// Timestamp (in milliseconds) at which the stream object was created
	CreatedAt *float64 `json:"createdAt,omitempty"`
	// Points to the parent stream object
	ParentID *string `json:"parentId,omitempty"`
	// Used to form the RTMP ingest URL
	StreamKey *string `json:"streamKey,omitempty"`
	// Used to form playback URL
	PlaybackID *string `json:"playbackId,omitempty"`
	// Whether the playback policy for a asset or stream is public or signed
	PlaybackPolicy *PlaybackPolicy `json:"playbackPolicy,omitempty"`
	Profiles       []FfmpegProfile `json:"profiles,omitempty"`
	// Should this stream be recorded? Uses default settings. For more
	// customization, create and configure an object store.
	//
	Record      *bool              `json:"record,omitempty"`
	Multistream *StreamMultistream `json:"multistream,omitempty"`
	// If currently suspended
	Suspended *bool `json:"suspended,omitempty"`
}

func (o *Stream) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Stream) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Stream) GetCreatorID() *CreatorID {
	if o == nil {
		return nil
	}
	return o.CreatorID
}

func (o *Stream) GetLastSeen() *float64 {
	if o == nil {
		return nil
	}
	return o.LastSeen
}

func (o *Stream) GetSourceSegments() *float64 {
	if o == nil {
		return nil
	}
	return o.SourceSegments
}

func (o *Stream) GetTranscodedSegments() *float64 {
	if o == nil {
		return nil
	}
	return o.TranscodedSegments
}

func (o *Stream) GetSourceSegmentsDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.SourceSegmentsDuration
}

func (o *Stream) GetTranscodedSegmentsDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.TranscodedSegmentsDuration
}

func (o *Stream) GetSourceBytes() *float64 {
	if o == nil {
		return nil
	}
	return o.SourceBytes
}

func (o *Stream) GetTranscodedBytes() *float64 {
	if o == nil {
		return nil
	}
	return o.TranscodedBytes
}

func (o *Stream) GetIngestRate() *float64 {
	if o == nil {
		return nil
	}
	return o.IngestRate
}

func (o *Stream) GetOutgoingRate() *float64 {
	if o == nil {
		return nil
	}
	return o.OutgoingRate
}

func (o *Stream) GetIsActive() *bool {
	if o == nil {
		return nil
	}
	return o.IsActive
}

func (o *Stream) GetIsHealthy() *bool {
	if o == nil {
		return nil
	}
	return o.IsHealthy
}

func (o *Stream) GetIssues() []string {
	if o == nil {
		return nil
	}
	return o.Issues
}

func (o *Stream) GetCreatedByTokenName() *string {
	if o == nil {
		return nil
	}
	return o.CreatedByTokenName
}

func (o *Stream) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Stream) GetParentID() *string {
	if o == nil {
		return nil
	}
	return o.ParentID
}

func (o *Stream) GetStreamKey() *string {
	if o == nil {
		return nil
	}
	return o.StreamKey
}

func (o *Stream) GetPlaybackID() *string {
	if o == nil {
		return nil
	}
	return o.PlaybackID
}

func (o *Stream) GetPlaybackPolicy() *PlaybackPolicy {
	if o == nil {
		return nil
	}
	return o.PlaybackPolicy
}

func (o *Stream) GetProfiles() []FfmpegProfile {
	if o == nil {
		return nil
	}
	return o.Profiles
}

func (o *Stream) GetRecord() *bool {
	if o == nil {
		return nil
	}
	return o.Record
}

func (o *Stream) GetMultistream() *StreamMultistream {
	if o == nil {
		return nil
	}
	return o.Multistream
}

func (o *Stream) GetSuspended() *bool {
	if o == nil {
		return nil
	}
	return o.Suspended
}
