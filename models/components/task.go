// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"livepeer/internal/utils"
)

// TaskType - Type of the task
type TaskType string

const (
	TaskTypeUpload        TaskType = "upload"
	TaskTypeImport        TaskType = "import"
	TaskTypeExport        TaskType = "export"
	TaskTypeExportData    TaskType = "export-data"
	TaskTypeTranscode     TaskType = "transcode"
	TaskTypeTranscodeFile TaskType = "transcode-file"
	TaskTypeClip          TaskType = "clip"
)

func (e TaskType) ToPointer() *TaskType {
	return &e
}

func (e *TaskType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "upload":
		fallthrough
	case "import":
		fallthrough
	case "export":
		fallthrough
	case "export-data":
		fallthrough
	case "transcode":
		fallthrough
	case "transcode-file":
		fallthrough
	case "clip":
		*e = TaskType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TaskType: %v", v)
	}
}

// TaskSchemasUploadOutput - Parameters for the upload task
type TaskSchemasUploadOutput struct {
	// URL of the asset to "upload"
	URL        *string           `json:"url,omitempty"`
	Encryption *EncryptionOutput `json:"encryption,omitempty"`
	// ID of the original recorded session to avoid re-transcoding
	// of the same content. Only used for import task.
	//
	RecordedSessionID *string `json:"recordedSessionId,omitempty"`
}

func (o *TaskSchemasUploadOutput) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *TaskSchemasUploadOutput) GetEncryption() *EncryptionOutput {
	if o == nil {
		return nil
	}
	return o.Encryption
}

func (o *TaskSchemasUploadOutput) GetRecordedSessionID() *string {
	if o == nil {
		return nil
	}
	return o.RecordedSessionID
}

// Content - File content to store into IPFS
type Content struct {
}

// ExportData - Parameters for the export-data task
type ExportData struct {
	// File content to store into IPFS
	Content Content           `json:"content"`
	Ipfs    *IpfsExportParams `json:"ipfs,omitempty"`
	// Optional type of content
	Type *string `json:"type,omitempty"`
	// Optional ID of the content
	ID *string `json:"id,omitempty"`
}

func (o *ExportData) GetContent() Content {
	if o == nil {
		return Content{}
	}
	return o.Content
}

func (o *ExportData) GetIpfs() *IpfsExportParams {
	if o == nil {
		return nil
	}
	return o.Ipfs
}

func (o *ExportData) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *ExportData) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// Transcode - Parameters for the transcode task
type Transcode struct {
	// LMPS ffmpeg profile
	Profile *FfmpegProfile `json:"profile,omitempty"`
}

func (o *Transcode) GetProfile() *FfmpegProfile {
	if o == nil {
		return nil
	}
	return o.Profile
}

// Input video file to transcode
type Input struct {
	// URL of a video to transcode, accepts object-store format
	// "s3+https"
	//
	URL *string `json:"url,omitempty"`
}

func (o *Input) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

// TaskStorage - Storage for the output files
type TaskStorage struct {
	// URL of the output storage, accepts object-store format
	// "s3+https"
	//
	URL *string `json:"url,omitempty"`
}

func (o *TaskStorage) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

// Hls - HLS output format
type Hls struct {
	// Path for the HLS output
	Path *string `json:"path,omitempty"`
}

func (o *Hls) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// Mp4 - MP4 output format
type Mp4 struct {
	// Path for the MP4 output
	Path *string `json:"path,omitempty"`
}

func (o *Mp4) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// Outputs - Output formats
type Outputs struct {
	// HLS output format
	Hls *Hls `json:"hls,omitempty"`
	// MP4 output format
	Mp4 *Mp4 `json:"mp4,omitempty"`
}

func (o *Outputs) GetHls() *Hls {
	if o == nil {
		return nil
	}
	return o.Hls
}

func (o *Outputs) GetMp4() *Mp4 {
	if o == nil {
		return nil
	}
	return o.Mp4
}

// TranscodeFile - Parameters for the transcode-file task
type TranscodeFile struct {
	// Input video file to transcode
	Input *Input `json:"input,omitempty"`
	// Storage for the output files
	Storage *TaskStorage `json:"storage,omitempty"`
	// Output formats
	Outputs  *Outputs        `json:"outputs,omitempty"`
	Profiles []FfmpegProfile `json:"profiles,omitempty"`
	// How many seconds the duration of each output segment should
	// be
	//
	TargetSegmentSizeSecs *float64        `json:"targetSegmentSizeSecs,omitempty"`
	CreatorID             *InputCreatorID `json:"creatorId,omitempty"`
}

func (o *TranscodeFile) GetInput() *Input {
	if o == nil {
		return nil
	}
	return o.Input
}

func (o *TranscodeFile) GetStorage() *TaskStorage {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *TranscodeFile) GetOutputs() *Outputs {
	if o == nil {
		return nil
	}
	return o.Outputs
}

func (o *TranscodeFile) GetProfiles() []FfmpegProfile {
	if o == nil {
		return nil
	}
	return o.Profiles
}

func (o *TranscodeFile) GetTargetSegmentSizeSecs() *float64 {
	if o == nil {
		return nil
	}
	return o.TargetSegmentSizeSecs
}

func (o *TranscodeFile) GetCreatorID() *InputCreatorID {
	if o == nil {
		return nil
	}
	return o.CreatorID
}

// TaskParams - Parameters of the task
type TaskParams struct {
	// Parameters for the upload task
	Upload *TaskSchemasUploadOutput `json:"upload,omitempty"`
	// Parameters for the upload task
	Import *UploadOutput1 `json:"import,omitempty"`
	// Parameters for the export task
	Export *ExportTaskParams `json:"export,omitempty"`
	// Parameters for the export-data task
	ExportData *ExportData `json:"exportData,omitempty"`
	// Parameters for the transcode task
	Transcode *Transcode `json:"transcode,omitempty"`
	// Parameters for the transcode-file task
	TranscodeFile *TranscodeFile `json:"transcode-file,omitempty"`
}

func (o *TaskParams) GetUpload() *TaskSchemasUploadOutput {
	if o == nil {
		return nil
	}
	return o.Upload
}

func (o *TaskParams) GetImport() *UploadOutput1 {
	if o == nil {
		return nil
	}
	return o.Import
}

func (o *TaskParams) GetExport() *ExportTaskParams {
	if o == nil {
		return nil
	}
	return o.Export
}

func (o *TaskParams) GetExportData() *ExportData {
	if o == nil {
		return nil
	}
	return o.ExportData
}

func (o *TaskParams) GetTranscode() *Transcode {
	if o == nil {
		return nil
	}
	return o.Transcode
}

func (o *TaskParams) GetTranscodeFile() *TranscodeFile {
	if o == nil {
		return nil
	}
	return o.TranscodeFile
}

// ClipStrategy - Strategy to use for clipping the asset. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
type ClipStrategy struct {
	// Start time of the clip in milliseconds
	StartTime *float64 `json:"startTime,omitempty"`
	// End time of the clip in milliseconds
	EndTime *float64 `json:"endTime,omitempty"`
	// Playback ID of the stream or asset to clip
	PlaybackID *string `json:"playbackId,omitempty"`
}

func (o *ClipStrategy) GetStartTime() *float64 {
	if o == nil {
		return nil
	}
	return o.StartTime
}

func (o *ClipStrategy) GetEndTime() *float64 {
	if o == nil {
		return nil
	}
	return o.EndTime
}

func (o *ClipStrategy) GetPlaybackID() *string {
	if o == nil {
		return nil
	}
	return o.PlaybackID
}

// CatalystPipelineStrategy - Force to use a specific strategy in the Catalyst pipeline. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
type CatalystPipelineStrategy string

const (
	CatalystPipelineStrategyCatalyst           CatalystPipelineStrategy = "catalyst"
	CatalystPipelineStrategyCatalystFfmpeg     CatalystPipelineStrategy = "catalyst_ffmpeg"
	CatalystPipelineStrategyBackgroundExternal CatalystPipelineStrategy = "background_external"
	CatalystPipelineStrategyBackgroundMist     CatalystPipelineStrategy = "background_mist"
	CatalystPipelineStrategyFallbackExternal   CatalystPipelineStrategy = "fallback_external"
	CatalystPipelineStrategyExternal           CatalystPipelineStrategy = "external"
)

func (e CatalystPipelineStrategy) ToPointer() *CatalystPipelineStrategy {
	return &e
}

func (e *CatalystPipelineStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "catalyst":
		fallthrough
	case "catalyst_ffmpeg":
		fallthrough
	case "background_external":
		fallthrough
	case "background_mist":
		fallthrough
	case "fallback_external":
		fallthrough
	case "external":
		*e = CatalystPipelineStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CatalystPipelineStrategy: %v", v)
	}
}

type Clip struct {
	// URL of the asset to "clip"
	URL *string `json:"url,omitempty"`
	// Strategy to use for clipping the asset. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
	ClipStrategy *ClipStrategy `json:"clipStrategy,omitempty"`
	// Force to use a specific strategy in the Catalyst pipeline. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
	CatalystPipelineStrategy *CatalystPipelineStrategy `json:"catalystPipelineStrategy,omitempty"`
	// ID of the session
	SessionID *string `json:"sessionId,omitempty"`
	// ID of the input asset or stream
	InputID *string `json:"inputId,omitempty"`
}

func (o *Clip) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *Clip) GetClipStrategy() *ClipStrategy {
	if o == nil {
		return nil
	}
	return o.ClipStrategy
}

func (o *Clip) GetCatalystPipelineStrategy() *CatalystPipelineStrategy {
	if o == nil {
		return nil
	}
	return o.CatalystPipelineStrategy
}

func (o *Clip) GetSessionID() *string {
	if o == nil {
		return nil
	}
	return o.SessionID
}

func (o *Clip) GetInputID() *string {
	if o == nil {
		return nil
	}
	return o.InputID
}

// TaskPhase - Phase of the task
type TaskPhase string

const (
	TaskPhasePending   TaskPhase = "pending"
	TaskPhaseWaiting   TaskPhase = "waiting"
	TaskPhaseRunning   TaskPhase = "running"
	TaskPhaseFailed    TaskPhase = "failed"
	TaskPhaseCompleted TaskPhase = "completed"
	TaskPhaseCancelled TaskPhase = "cancelled"
)

func (e TaskPhase) ToPointer() *TaskPhase {
	return &e
}

func (e *TaskPhase) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pending":
		fallthrough
	case "waiting":
		fallthrough
	case "running":
		fallthrough
	case "failed":
		fallthrough
	case "completed":
		fallthrough
	case "cancelled":
		*e = TaskPhase(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TaskPhase: %v", v)
	}
}

// TaskStatus - Status of the task
type TaskStatus struct {
	// Phase of the task
	Phase TaskPhase `json:"phase"`
	// Timestamp (in milliseconds) at which task was updated
	UpdatedAt float64 `json:"updatedAt"`
	// Current progress of the task in a 0-1 ratio
	Progress *float64 `json:"progress,omitempty"`
	// Error message if the task failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Number of retries done on the task
	Retries *float64 `json:"retries,omitempty"`
}

func (o *TaskStatus) GetPhase() TaskPhase {
	if o == nil {
		return TaskPhase("")
	}
	return o.Phase
}

func (o *TaskStatus) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *TaskStatus) GetProgress() *float64 {
	if o == nil {
		return nil
	}
	return o.Progress
}

func (o *TaskStatus) GetErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ErrorMessage
}

func (o *TaskStatus) GetRetries() *float64 {
	if o == nil {
		return nil
	}
	return o.Retries
}

// TaskUploadOutput - Output of the upload task
type TaskUploadOutput struct {
	AssetSpec            *Asset                 `json:"assetSpec,omitempty"`
	AdditionalProperties map[string]interface{} `additionalProperties:"true" json:"-"`
}

func (t TaskUploadOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TaskUploadOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *TaskUploadOutput) GetAssetSpec() *Asset {
	if o == nil {
		return nil
	}
	return o.AssetSpec
}

func (o *TaskUploadOutput) GetAdditionalProperties() map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type TaskIpfs struct {
	// IPFS CID of the exported video file
	VideoFileCid string `json:"videoFileCid"`
	// URL for the file with the IPFS protocol
	VideoFileURL *string `json:"videoFileUrl,omitempty"`
	// URL to access file via HTTP through an IPFS gateway
	VideoFileGatewayURL *string `json:"videoFileGatewayUrl,omitempty"`
	// IPFS CID of the default metadata exported for the video
	NftMetadataCid *string `json:"nftMetadataCid,omitempty"`
	// URL for the metadata file with the IPFS protocol
	NftMetadataURL *string `json:"nftMetadataUrl,omitempty"`
	// URL to access metadata file via HTTP through an IPFS
	// gateway
	//
	NftMetadataGatewayURL *string `json:"nftMetadataGatewayUrl,omitempty"`
}

func (o *TaskIpfs) GetVideoFileCid() string {
	if o == nil {
		return ""
	}
	return o.VideoFileCid
}

func (o *TaskIpfs) GetVideoFileURL() *string {
	if o == nil {
		return nil
	}
	return o.VideoFileURL
}

func (o *TaskIpfs) GetVideoFileGatewayURL() *string {
	if o == nil {
		return nil
	}
	return o.VideoFileGatewayURL
}

func (o *TaskIpfs) GetNftMetadataCid() *string {
	if o == nil {
		return nil
	}
	return o.NftMetadataCid
}

func (o *TaskIpfs) GetNftMetadataURL() *string {
	if o == nil {
		return nil
	}
	return o.NftMetadataURL
}

func (o *TaskIpfs) GetNftMetadataGatewayURL() *string {
	if o == nil {
		return nil
	}
	return o.NftMetadataGatewayURL
}

// Export - Output of the export task
type Export struct {
	Ipfs *TaskIpfs `json:"ipfs,omitempty"`
}

func (o *Export) GetIpfs() *TaskIpfs {
	if o == nil {
		return nil
	}
	return o.Ipfs
}

type TaskSchemasIpfs struct {
	// IPFS CID of the exported data
	Cid string `json:"cid"`
}

func (o *TaskSchemasIpfs) GetCid() string {
	if o == nil {
		return ""
	}
	return o.Cid
}

// TaskSchemasExportData - Output of the export data task
type TaskSchemasExportData struct {
	Ipfs *TaskSchemasIpfs `json:"ipfs,omitempty"`
}

func (o *TaskSchemasExportData) GetIpfs() *TaskSchemasIpfs {
	if o == nil {
		return nil
	}
	return o.Ipfs
}

type TaskAsset struct {
	VideoFilePath        *string                `json:"videoFilePath,omitempty"`
	MetadataFilePath     *string                `json:"metadataFilePath,omitempty"`
	AssetSpec            *Asset                 `json:"assetSpec,omitempty"`
	AdditionalProperties map[string]interface{} `additionalProperties:"true" json:"-"`
}

func (t TaskAsset) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TaskAsset) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *TaskAsset) GetVideoFilePath() *string {
	if o == nil {
		return nil
	}
	return o.VideoFilePath
}

func (o *TaskAsset) GetMetadataFilePath() *string {
	if o == nil {
		return nil
	}
	return o.MetadataFilePath
}

func (o *TaskAsset) GetAssetSpec() *Asset {
	if o == nil {
		return nil
	}
	return o.AssetSpec
}

func (o *TaskAsset) GetAdditionalProperties() map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type TaskTranscode struct {
	Asset *TaskAsset `json:"asset,omitempty"`
}

func (o *TaskTranscode) GetAsset() *TaskAsset {
	if o == nil {
		return nil
	}
	return o.Asset
}

// Output of the task
type Output struct {
	// Output of the upload task
	Upload *TaskUploadOutput `json:"upload,omitempty"`
	// Output of the upload task
	Import *UploadOutput `json:"import,omitempty"`
	// Output of the export task
	Export *Export `json:"export,omitempty"`
	// Output of the export data task
	ExportData *TaskSchemasExportData `json:"exportData,omitempty"`
	Transcode  *TaskTranscode         `json:"transcode,omitempty"`
}

func (o *Output) GetUpload() *TaskUploadOutput {
	if o == nil {
		return nil
	}
	return o.Upload
}

func (o *Output) GetImport() *UploadOutput {
	if o == nil {
		return nil
	}
	return o.Import
}

func (o *Output) GetExport() *Export {
	if o == nil {
		return nil
	}
	return o.Export
}

func (o *Output) GetExportData() *TaskSchemasExportData {
	if o == nil {
		return nil
	}
	return o.ExportData
}

func (o *Output) GetTranscode() *TaskTranscode {
	if o == nil {
		return nil
	}
	return o.Transcode
}

type Task struct {
	// Task ID
	ID *string `json:"id,omitempty"`
	// Type of the task
	Type *TaskType `json:"type,omitempty"`
	// Timestamp (in milliseconds) at which task was created
	CreatedAt *float64 `json:"createdAt,omitempty"`
	// Timestamp (in milliseconds) at which the task was scheduled for
	// execution (e.g. after file upload finished).
	//
	ScheduledAt *float64 `json:"scheduledAt,omitempty"`
	// ID of the input asset
	InputAssetID *string `json:"inputAssetId,omitempty"`
	// ID of the output asset
	OutputAssetID *string `json:"outputAssetId,omitempty"`
	// Parameters of the task
	Params *TaskParams `json:"params,omitempty"`
	Clip   *Clip       `json:"clip,omitempty"`
	// Status of the task
	Status *TaskStatus `json:"status,omitempty"`
	// Output of the task
	Output *Output `json:"output,omitempty"`
}

func (o *Task) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Task) GetType() *TaskType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Task) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Task) GetScheduledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ScheduledAt
}

func (o *Task) GetInputAssetID() *string {
	if o == nil {
		return nil
	}
	return o.InputAssetID
}

func (o *Task) GetOutputAssetID() *string {
	if o == nil {
		return nil
	}
	return o.OutputAssetID
}

func (o *Task) GetParams() *TaskParams {
	if o == nil {
		return nil
	}
	return o.Params
}

func (o *Task) GetClip() *Clip {
	if o == nil {
		return nil
	}
	return o.Clip
}

func (o *Task) GetStatus() *TaskStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Task) GetOutput() *Output {
	if o == nil {
		return nil
	}
	return o.Output
}

// TaskUpload - Parameters for the upload task
type TaskUpload struct {
	// URL of the asset to "upload"
	URL        *string     `json:"url,omitempty"`
	Encryption *Encryption `json:"encryption,omitempty"`
	// ID of the original recorded session to avoid re-transcoding
	// of the same content. Only used for import task.
	//
	RecordedSessionID *string `json:"recordedSessionId,omitempty"`
}

func (o *TaskUpload) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *TaskUpload) GetEncryption() *Encryption {
	if o == nil {
		return nil
	}
	return o.Encryption
}

func (o *TaskUpload) GetRecordedSessionID() *string {
	if o == nil {
		return nil
	}
	return o.RecordedSessionID
}

// TaskExportData - Parameters for the export-data task
type TaskExportData struct {
	// File content to store into IPFS
	Content Content            `json:"content"`
	Ipfs    *IpfsExportParams1 `json:"ipfs,omitempty"`
	// Optional type of content
	Type *string `json:"type,omitempty"`
	// Optional ID of the content
	ID *string `json:"id,omitempty"`
}

func (o *TaskExportData) GetContent() Content {
	if o == nil {
		return Content{}
	}
	return o.Content
}

func (o *TaskExportData) GetIpfs() *IpfsExportParams1 {
	if o == nil {
		return nil
	}
	return o.Ipfs
}

func (o *TaskExportData) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *TaskExportData) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// Params - Parameters of the task
type Params struct {
	// Parameters for the upload task
	Upload *TaskUpload `json:"upload,omitempty"`
	// Parameters for the upload task
	Import *Upload `json:"import,omitempty"`
	// Parameters for the export task
	Export *ExportTaskParams1 `json:"export,omitempty"`
	// Parameters for the export-data task
	ExportData *TaskExportData `json:"exportData,omitempty"`
	// Parameters for the transcode task
	Transcode *Transcode `json:"transcode,omitempty"`
	// Parameters for the transcode-file task
	TranscodeFile *TranscodeFile `json:"transcode-file,omitempty"`
}

func (o *Params) GetUpload() *TaskUpload {
	if o == nil {
		return nil
	}
	return o.Upload
}

func (o *Params) GetImport() *Upload {
	if o == nil {
		return nil
	}
	return o.Import
}

func (o *Params) GetExport() *ExportTaskParams1 {
	if o == nil {
		return nil
	}
	return o.Export
}

func (o *Params) GetExportData() *TaskExportData {
	if o == nil {
		return nil
	}
	return o.ExportData
}

func (o *Params) GetTranscode() *Transcode {
	if o == nil {
		return nil
	}
	return o.Transcode
}

func (o *Params) GetTranscodeFile() *TranscodeFile {
	if o == nil {
		return nil
	}
	return o.TranscodeFile
}

// TaskUploadInput - Output of the upload task
type TaskUploadInput struct {
	VideoFilePath        *string                `json:"videoFilePath,omitempty"`
	MetadataFilePath     *string                `json:"metadataFilePath,omitempty"`
	AssetSpec            *AssetInput            `json:"assetSpec,omitempty"`
	AdditionalProperties map[string]interface{} `additionalProperties:"true" json:"-"`
}

func (t TaskUploadInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TaskUploadInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *TaskUploadInput) GetVideoFilePath() *string {
	if o == nil {
		return nil
	}
	return o.VideoFilePath
}

func (o *TaskUploadInput) GetMetadataFilePath() *string {
	if o == nil {
		return nil
	}
	return o.MetadataFilePath
}

func (o *TaskUploadInput) GetAssetSpec() *AssetInput {
	if o == nil {
		return nil
	}
	return o.AssetSpec
}

func (o *TaskUploadInput) GetAdditionalProperties() map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type TaskIpfsInput struct {
	// IPFS CID of the exported video file
	VideoFileCid string `json:"videoFileCid"`
	// IPFS CID of the default metadata exported for the video
	NftMetadataCid *string `json:"nftMetadataCid,omitempty"`
}

func (o *TaskIpfsInput) GetVideoFileCid() string {
	if o == nil {
		return ""
	}
	return o.VideoFileCid
}

func (o *TaskIpfsInput) GetNftMetadataCid() *string {
	if o == nil {
		return nil
	}
	return o.NftMetadataCid
}

// TaskExport - Output of the export task
type TaskExport struct {
	Ipfs *TaskIpfsInput `json:"ipfs,omitempty"`
}

func (o *TaskExport) GetIpfs() *TaskIpfsInput {
	if o == nil {
		return nil
	}
	return o.Ipfs
}

type TaskAssetInput struct {
	VideoFilePath        *string                `json:"videoFilePath,omitempty"`
	MetadataFilePath     *string                `json:"metadataFilePath,omitempty"`
	AssetSpec            *AssetInput            `json:"assetSpec,omitempty"`
	AdditionalProperties map[string]interface{} `additionalProperties:"true" json:"-"`
}

func (t TaskAssetInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TaskAssetInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *TaskAssetInput) GetVideoFilePath() *string {
	if o == nil {
		return nil
	}
	return o.VideoFilePath
}

func (o *TaskAssetInput) GetMetadataFilePath() *string {
	if o == nil {
		return nil
	}
	return o.MetadataFilePath
}

func (o *TaskAssetInput) GetAssetSpec() *AssetInput {
	if o == nil {
		return nil
	}
	return o.AssetSpec
}

func (o *TaskAssetInput) GetAdditionalProperties() map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type TaskTranscodeInput struct {
	Asset *TaskAssetInput `json:"asset,omitempty"`
}

func (o *TaskTranscodeInput) GetAsset() *TaskAssetInput {
	if o == nil {
		return nil
	}
	return o.Asset
}

// TaskOutput - Output of the task
type TaskOutput struct {
	// Output of the upload task
	Upload *TaskUploadInput `json:"upload,omitempty"`
	// Output of the upload task
	Import *UploadInput `json:"import,omitempty"`
	// Output of the export task
	Export *TaskExport `json:"export,omitempty"`
	// Output of the export data task
	ExportData *TaskSchemasExportData `json:"exportData,omitempty"`
	Transcode  *TaskTranscodeInput    `json:"transcode,omitempty"`
}

func (o *TaskOutput) GetUpload() *TaskUploadInput {
	if o == nil {
		return nil
	}
	return o.Upload
}

func (o *TaskOutput) GetImport() *UploadInput {
	if o == nil {
		return nil
	}
	return o.Import
}

func (o *TaskOutput) GetExport() *TaskExport {
	if o == nil {
		return nil
	}
	return o.Export
}

func (o *TaskOutput) GetExportData() *TaskSchemasExportData {
	if o == nil {
		return nil
	}
	return o.ExportData
}

func (o *TaskOutput) GetTranscode() *TaskTranscodeInput {
	if o == nil {
		return nil
	}
	return o.Transcode
}

type TaskInput struct {
	// Type of the task
	Type *TaskType `json:"type,omitempty"`
	// ID of the input asset
	InputAssetID *string `json:"inputAssetId,omitempty"`
	// ID of the output asset
	OutputAssetID *string `json:"outputAssetId,omitempty"`
	// Parameters of the task
	Params *Params `json:"params,omitempty"`
	Clip   *Clip   `json:"clip,omitempty"`
	// Output of the task
	Output *TaskOutput `json:"output,omitempty"`
}

func (o *TaskInput) GetType() *TaskType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *TaskInput) GetInputAssetID() *string {
	if o == nil {
		return nil
	}
	return o.InputAssetID
}

func (o *TaskInput) GetOutputAssetID() *string {
	if o == nil {
		return nil
	}
	return o.OutputAssetID
}

func (o *TaskInput) GetParams() *Params {
	if o == nil {
		return nil
	}
	return o.Params
}

func (o *TaskInput) GetClip() *Clip {
	if o == nil {
		return nil
	}
	return o.Clip
}

func (o *TaskInput) GetOutput() *TaskOutput {
	if o == nil {
		return nil
	}
	return o.Output
}
