// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/livepeer/livepeer-go/internal/utils"
)

// AssetType - Type of the asset.
type AssetType string

const (
	AssetTypeVideo AssetType = "video"
	AssetTypeAudio AssetType = "audio"
)

func (e AssetType) ToPointer() *AssetType {
	return &e
}
func (e *AssetType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "video":
		fallthrough
	case "audio":
		*e = AssetType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetType: %v", v)
	}
}

type AssetSource3Type string

const (
	AssetSource3TypeDirectUpload AssetSource3Type = "directUpload"
	AssetSource3TypeClip         AssetSource3Type = "clip"
)

func (e AssetSource3Type) ToPointer() *AssetSource3Type {
	return &e
}
func (e *AssetSource3Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "directUpload":
		fallthrough
	case "clip":
		*e = AssetSource3Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetSource3Type: %v", v)
	}
}

type Source3 struct {
	Type       AssetSource3Type  `json:"type"`
	Encryption *EncryptionOutput `json:"encryption,omitempty"`
	// ID of the asset or stream from which this asset was created.
	SourceID *string `json:"sourceId,omitempty"`
	// ID of the session from which this asset was created.
	SessionID *string `json:"sessionId,omitempty"`
	// Playback ID of the asset or stream from which this asset was created.
	PlaybackID *string `json:"playbackId,omitempty"`
	// ID of the requester from which this asset was created.
	RequesterID *string `json:"requesterId,omitempty"`
	// ID of the asset from which this asset was created.
	AssetID *string `json:"assetId,omitempty"`
}

func (o *Source3) GetType() AssetSource3Type {
	if o == nil {
		return AssetSource3Type("")
	}
	return o.Type
}

func (o *Source3) GetEncryption() *EncryptionOutput {
	if o == nil {
		return nil
	}
	return o.Encryption
}

func (o *Source3) GetSourceID() *string {
	if o == nil {
		return nil
	}
	return o.SourceID
}

func (o *Source3) GetSessionID() *string {
	if o == nil {
		return nil
	}
	return o.SessionID
}

func (o *Source3) GetPlaybackID() *string {
	if o == nil {
		return nil
	}
	return o.PlaybackID
}

func (o *Source3) GetRequesterID() *string {
	if o == nil {
		return nil
	}
	return o.RequesterID
}

func (o *Source3) GetAssetID() *string {
	if o == nil {
		return nil
	}
	return o.AssetID
}

type AssetSourceType string

const (
	AssetSourceTypeRecording AssetSourceType = "recording"
)

func (e AssetSourceType) ToPointer() *AssetSourceType {
	return &e
}
func (e *AssetSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "recording":
		*e = AssetSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetSourceType: %v", v)
	}
}

type Two struct {
	Type AssetSourceType `json:"type"`
	// ID of the session from which this asset was created
	SessionID string `json:"sessionId"`
}

func (o *Two) GetType() AssetSourceType {
	if o == nil {
		return AssetSourceType("")
	}
	return o.Type
}

func (o *Two) GetSessionID() string {
	if o == nil {
		return ""
	}
	return o.SessionID
}

type SourceType string

const (
	SourceTypeURL SourceType = "url"
)

func (e SourceType) ToPointer() *SourceType {
	return &e
}
func (e *SourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "url":
		*e = SourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceType: %v", v)
	}
}

type Source1 struct {
	Type SourceType `json:"type"`
	// URL from which the asset was uploaded.
	URL string `json:"url"`
	// Gateway URL from asset if parsed from provided URL on upload.
	GatewayURL *string           `json:"gatewayUrl,omitempty"`
	Encryption *EncryptionOutput `json:"encryption,omitempty"`
}

func (o *Source1) GetType() SourceType {
	if o == nil {
		return SourceType("")
	}
	return o.Type
}

func (o *Source1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *Source1) GetGatewayURL() *string {
	if o == nil {
		return nil
	}
	return o.GatewayURL
}

func (o *Source1) GetEncryption() *EncryptionOutput {
	if o == nil {
		return nil
	}
	return o.Encryption
}

type SourceUnionType string

const (
	SourceUnionTypeSource1 SourceUnionType = "source_1"
	SourceUnionTypeTwo     SourceUnionType = "2"
	SourceUnionTypeSource3 SourceUnionType = "source_3"
)

type Source struct {
	Source1 *Source1
	Two     *Two
	Source3 *Source3

	Type SourceUnionType
}

func CreateSourceSource1(source1 Source1) Source {
	typ := SourceUnionTypeSource1

	return Source{
		Source1: &source1,
		Type:    typ,
	}
}

func CreateSourceTwo(two Two) Source {
	typ := SourceUnionTypeTwo

	return Source{
		Two:  &two,
		Type: typ,
	}
}

func CreateSourceSource3(source3 Source3) Source {
	typ := SourceUnionTypeSource3

	return Source{
		Source3: &source3,
		Type:    typ,
	}
}

func (u *Source) UnmarshalJSON(data []byte) error {

	var two Two = Two{}
	if err := utils.UnmarshalJSON(data, &two, "", true, true); err == nil {
		u.Two = &two
		u.Type = SourceUnionTypeTwo
		return nil
	}

	var source1 Source1 = Source1{}
	if err := utils.UnmarshalJSON(data, &source1, "", true, true); err == nil {
		u.Source1 = &source1
		u.Type = SourceUnionTypeSource1
		return nil
	}

	var source3 Source3 = Source3{}
	if err := utils.UnmarshalJSON(data, &source3, "", true, true); err == nil {
		u.Source3 = &source3
		u.Type = SourceUnionTypeSource3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Source", string(data))
}

func (u Source) MarshalJSON() ([]byte, error) {
	if u.Source1 != nil {
		return utils.MarshalJSON(u.Source1, "", true)
	}

	if u.Two != nil {
		return utils.MarshalJSON(u.Two, "", true)
	}

	if u.Source3 != nil {
		return utils.MarshalJSON(u.Source3, "", true)
	}

	return nil, errors.New("could not marshal union type Source: all fields are null")
}

// AssetNftMetadataTemplate - Name of the NFT metadata template to export. 'player'
// will embed the Livepeer Player on the NFT while 'file'
// will reference only the immutable MP4 files.
type AssetNftMetadataTemplate string

const (
	AssetNftMetadataTemplateFile   AssetNftMetadataTemplate = "file"
	AssetNftMetadataTemplatePlayer AssetNftMetadataTemplate = "player"
)

func (e AssetNftMetadataTemplate) ToPointer() *AssetNftMetadataTemplate {
	return &e
}
func (e *AssetNftMetadataTemplate) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		fallthrough
	case "player":
		*e = AssetNftMetadataTemplate(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetNftMetadataTemplate: %v", v)
	}
}

// AssetNftMetadata - Additional data to add to the NFT metadata exported to
// IPFS. Will be deep merged with the default metadata
// exported.
type AssetNftMetadata struct {
}

type AssetSpec struct {
	// Name of the NFT metadata template to export. 'player'
	// will embed the Livepeer Player on the NFT while 'file'
	// will reference only the immutable MP4 files.
	//
	NftMetadataTemplate *AssetNftMetadataTemplate `default:"file" json:"nftMetadataTemplate"`
	// Additional data to add to the NFT metadata exported to
	// IPFS. Will be deep merged with the default metadata
	// exported.
	//
	NftMetadata *AssetNftMetadata `json:"nftMetadata,omitempty"`
}

func (a AssetSpec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AssetSpec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AssetSpec) GetNftMetadataTemplate() *AssetNftMetadataTemplate {
	if o == nil {
		return nil
	}
	return o.NftMetadataTemplate
}

func (o *AssetSpec) GetNftMetadata() *AssetNftMetadata {
	if o == nil {
		return nil
	}
	return o.NftMetadata
}

type AssetIpfs struct {
	Spec        *AssetSpec    `json:"spec,omitempty"`
	DollarRef   any           `json:"$ref,omitempty"`
	NftMetadata *IpfsFileInfo `json:"nftMetadata,omitempty"`
	// Timestamp (in milliseconds) at which IPFS export task was
	// updated
	//
	UpdatedAt *float64 `json:"updatedAt,omitempty"`
}

func (o *AssetIpfs) GetSpec() *AssetSpec {
	if o == nil {
		return nil
	}
	return o.Spec
}

func (o *AssetIpfs) GetDollarRef() any {
	if o == nil {
		return nil
	}
	return o.DollarRef
}

func (o *AssetIpfs) GetNftMetadata() *IpfsFileInfo {
	if o == nil {
		return nil
	}
	return o.NftMetadata
}

func (o *AssetIpfs) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

type AssetStorage struct {
	Ipfs   *AssetIpfs     `json:"ipfs,omitempty"`
	Status *StorageStatus `json:"status,omitempty"`
}

func (o *AssetStorage) GetIpfs() *AssetIpfs {
	if o == nil {
		return nil
	}
	return o.Ipfs
}

func (o *AssetStorage) GetStatus() *StorageStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

// AssetPhase - Phase of the asset
type AssetPhase string

const (
	AssetPhaseUploading  AssetPhase = "uploading"
	AssetPhaseWaiting    AssetPhase = "waiting"
	AssetPhaseProcessing AssetPhase = "processing"
	AssetPhaseReady      AssetPhase = "ready"
	AssetPhaseFailed     AssetPhase = "failed"
	AssetPhaseDeleting   AssetPhase = "deleting"
	AssetPhaseDeleted    AssetPhase = "deleted"
)

func (e AssetPhase) ToPointer() *AssetPhase {
	return &e
}
func (e *AssetPhase) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "uploading":
		fallthrough
	case "waiting":
		fallthrough
	case "processing":
		fallthrough
	case "ready":
		fallthrough
	case "failed":
		fallthrough
	case "deleting":
		fallthrough
	case "deleted":
		*e = AssetPhase(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetPhase: %v", v)
	}
}

// AssetStatus - Status of the asset
type AssetStatus struct {
	// Phase of the asset
	Phase AssetPhase `json:"phase"`
	// Timestamp (in milliseconds) at which the asset was last updated
	UpdatedAt float64 `json:"updatedAt"`
	// Current progress of the task creating this asset.
	Progress *float64 `json:"progress,omitempty"`
	// Error message if the asset creation failed.
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

func (o *AssetStatus) GetPhase() AssetPhase {
	if o == nil {
		return AssetPhase("")
	}
	return o.Phase
}

func (o *AssetStatus) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *AssetStatus) GetProgress() *float64 {
	if o == nil {
		return nil
	}
	return o.Progress
}

func (o *AssetStatus) GetErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ErrorMessage
}

type Hash struct {
	// Hash of the asset
	Hash *string `json:"hash,omitempty"`
	// Hash algorithm used to compute the hash
	Algorithm *string `json:"algorithm,omitempty"`
}

func (o *Hash) GetHash() *string {
	if o == nil {
		return nil
	}
	return o.Hash
}

func (o *Hash) GetAlgorithm() *string {
	if o == nil {
		return nil
	}
	return o.Algorithm
}

// AssetVideoSpecType - type of track
type AssetVideoSpecType string

const (
	AssetVideoSpecTypeVideo AssetVideoSpecType = "video"
	AssetVideoSpecTypeAudio AssetVideoSpecType = "audio"
)

func (e AssetVideoSpecType) ToPointer() *AssetVideoSpecType {
	return &e
}
func (e *AssetVideoSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "video":
		fallthrough
	case "audio":
		*e = AssetVideoSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetVideoSpecType: %v", v)
	}
}

type Tracks struct {
	// type of track
	Type AssetVideoSpecType `json:"type"`
	// Codec of the track
	Codec string `json:"codec"`
	// Start time of the track in seconds
	StartTime *float64 `json:"startTime,omitempty"`
	// Duration of the track in seconds
	Duration *float64 `json:"duration,omitempty"`
	// Bitrate of the track in bits per second
	Bitrate *float64 `json:"bitrate,omitempty"`
	// Width of the track - only for video tracks
	Width *float64 `json:"width,omitempty"`
	// Height of the track - only for video tracks
	Height *float64 `json:"height,omitempty"`
	// Pixel format of the track - only for video tracks
	PixelFormat *string `json:"pixelFormat,omitempty"`
	// Frame rate of the track - only for video tracks
	Fps *float64 `json:"fps,omitempty"`
	// Amount of audio channels in the track
	Channels *float64 `json:"channels,omitempty"`
	// Sample rate of the track in samples per second - only for
	// audio tracks
	//
	SampleRate *float64 `json:"sampleRate,omitempty"`
	// Bit depth of the track - only for audio tracks
	BitDepth *float64 `json:"bitDepth,omitempty"`
}

func (o *Tracks) GetType() AssetVideoSpecType {
	if o == nil {
		return AssetVideoSpecType("")
	}
	return o.Type
}

func (o *Tracks) GetCodec() string {
	if o == nil {
		return ""
	}
	return o.Codec
}

func (o *Tracks) GetStartTime() *float64 {
	if o == nil {
		return nil
	}
	return o.StartTime
}

func (o *Tracks) GetDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.Duration
}

func (o *Tracks) GetBitrate() *float64 {
	if o == nil {
		return nil
	}
	return o.Bitrate
}

func (o *Tracks) GetWidth() *float64 {
	if o == nil {
		return nil
	}
	return o.Width
}

func (o *Tracks) GetHeight() *float64 {
	if o == nil {
		return nil
	}
	return o.Height
}

func (o *Tracks) GetPixelFormat() *string {
	if o == nil {
		return nil
	}
	return o.PixelFormat
}

func (o *Tracks) GetFps() *float64 {
	if o == nil {
		return nil
	}
	return o.Fps
}

func (o *Tracks) GetChannels() *float64 {
	if o == nil {
		return nil
	}
	return o.Channels
}

func (o *Tracks) GetSampleRate() *float64 {
	if o == nil {
		return nil
	}
	return o.SampleRate
}

func (o *Tracks) GetBitDepth() *float64 {
	if o == nil {
		return nil
	}
	return o.BitDepth
}

// VideoSpec - Video metadata
type VideoSpec struct {
	// Format of the asset
	Format *string `json:"format,omitempty"`
	// Duration of the asset in seconds (float)
	Duration *float64 `json:"duration,omitempty"`
	// Bitrate of the video in bits per second
	Bitrate *float64 `json:"bitrate,omitempty"`
	// List of tracks associated with the asset when the format
	// contemplates them (e.g. mp4)
	//
	Tracks []Tracks `json:"tracks,omitempty"`
}

func (o *VideoSpec) GetFormat() *string {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *VideoSpec) GetDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.Duration
}

func (o *VideoSpec) GetBitrate() *float64 {
	if o == nil {
		return nil
	}
	return o.Bitrate
}

func (o *VideoSpec) GetTracks() []Tracks {
	if o == nil {
		return nil
	}
	return o.Tracks
}

type Asset struct {
	ID string `json:"id"`
	// Type of the asset.
	Type *AssetType `json:"type,omitempty"`
	// The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
	PlaybackID *string `json:"playbackId,omitempty"`
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	UserID *string `json:"userId,omitempty"`
	// URL for HLS playback. **It is recommended to not use this URL**, and instead use playback IDs with the Playback Info endpoint to retrieve the playback URLs - this URL format is subject to change (e.g. https://livepeercdn.com/asset/ea03f37e-f861-4cdd-b495-0e60b6d753ad/index.m3u8).
	PlaybackURL *string `json:"playbackUrl,omitempty"`
	// The URL to directly download the asset, e.g. `https://livepeercdn.com/asset/eawrrk06ts2d0mzb/video`. It is not recommended to use this for playback.
	DownloadURL *string `json:"downloadUrl,omitempty"`
	// Whether the playback policy for an asset or stream is public or signed
	PlaybackPolicy *PlaybackPolicy `json:"playbackPolicy,omitempty"`
	Source         Source          `json:"source"`
	CreatorID      *CreatorID      `json:"creatorId,omitempty"`
	Storage        *AssetStorage   `json:"storage,omitempty"`
	// Status of the asset
	Status *AssetStatus `json:"status,omitempty"`
	// The name of the asset. This is not necessarily the filename - it can be a custom name or title.
	//
	Name string `json:"name"`
	// The ID of the project
	ProjectID *string `json:"projectId,omitempty"`
	// Timestamp (in milliseconds) at which asset was created
	CreatedAt *float64 `json:"createdAt,omitempty"`
	// Name of the token used to create this object
	CreatedByTokenName *string `json:"createdByTokenName,omitempty"`
	// Size of the asset in bytes
	Size *float64 `json:"size,omitempty"`
	// Hash of the asset
	Hash []Hash `json:"hash,omitempty"`
	// Video metadata
	VideoSpec *VideoSpec `json:"videoSpec,omitempty"`
}

func (o *Asset) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Asset) GetType() *AssetType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Asset) GetPlaybackID() *string {
	if o == nil {
		return nil
	}
	return o.PlaybackID
}

func (o *Asset) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *Asset) GetPlaybackURL() *string {
	if o == nil {
		return nil
	}
	return o.PlaybackURL
}

func (o *Asset) GetDownloadURL() *string {
	if o == nil {
		return nil
	}
	return o.DownloadURL
}

func (o *Asset) GetPlaybackPolicy() *PlaybackPolicy {
	if o == nil {
		return nil
	}
	return o.PlaybackPolicy
}

func (o *Asset) GetSource() Source {
	if o == nil {
		return Source{}
	}
	return o.Source
}

func (o *Asset) GetCreatorID() *CreatorID {
	if o == nil {
		return nil
	}
	return o.CreatorID
}

func (o *Asset) GetStorage() *AssetStorage {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *Asset) GetStatus() *AssetStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Asset) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Asset) GetProjectID() *string {
	if o == nil {
		return nil
	}
	return o.ProjectID
}

func (o *Asset) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Asset) GetCreatedByTokenName() *string {
	if o == nil {
		return nil
	}
	return o.CreatedByTokenName
}

func (o *Asset) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *Asset) GetHash() []Hash {
	if o == nil {
		return nil
	}
	return o.Hash
}

func (o *Asset) GetVideoSpec() *VideoSpec {
	if o == nil {
		return nil
	}
	return o.VideoSpec
}
